<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Movimento e controles</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <script src="../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Some basic code and GML Visualto show people how to move things around within a game." />
  <meta name="rh-index-keywords" content="Quick Start - Movement And Controls" />
  <meta name="search-keywords" content="movement,controls" />
  <meta name="robots" content="NOODP" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Movimento e controles</h1>
  <p>A <a href="Drawing.htm">seção anterior</a> deste Guia Rápido deu alguns exemplos para desenhar coisas para a tela, mas apenas desenhar coisas não é muito bom se você também não puder movê-las... então nesta seção lhe daremos alguns exemplos de movimento para seu <span class="notranslate">objects</span>, assim como alguns esquemas básicos de controle para diferentes tipos de jogos. Todos os exemplos são dados usando <span class="notranslate">GML</span> Visual, bem como o código <span class="notranslate">GML</span>, para que você possa usar o que se sentir mais confortável com ele. Note que não vamos explicar as coisas com muita profundidade aqui, pois queremos que você comece a fazer as coisas o mais rápido possível, por isso encorajamos você a explorar quaisquer links à medida que for avançando e a usar a função de &quot;busca&quot; do manual para procurar informações adicionais sobre qualquer coisa que você não tenha certeza.</p>
  <p>Antes de continuar, você pode querer fazer um novo projeto (seja <span class="notranslate">GML</span> ou <span class="notranslate">GML</span> Visual) a partir da <a href="../Introduction/The_Start_Page.htm">página inicial</a>, e adicionar (ou criar) alguns <span class="notranslate">sprites</span>, bem como um <span class="notranslate">object</span> ou dois - pois lhe daremos algum código que você pode testar usando estes - e certificar-se de que o projeto tem um <span class="notranslate">room</span> para colocar instâncias em. Não se preocupe muito com a aparência do <span class="notranslate">sprites</span> que você faz, como até mesmo um simples quadrado branco fará, e uma vez que você tenha tudo pronto, você pode começar a trabalhar nos exemplos listados abaixo.</p>
  <p> </p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down" href="#">Mova-se em direção ao Rato</a></p>
  <div class="droptext" data-targetname="drop_down">
    <p class="dropspot">Uma das maneiras mais simples de conseguir um <span class="notranslate">object</span> movendo e interagindo com o jogador é usar o mouse, e neste exemplo mostraremos como usar algum código básico para conseguir um <span class="notranslate">object</span> para se mover para onde o usuário tiver clicado o botão esquerdo do mouse <img>.</p>
    <p class="dropspot">Para começar, abra um <span class="notranslate">object</span>, atribua-lhe um <span class="notranslate">sprite</span>, e depois dê-lhe um <strong>evento Global Left Mouse Down</strong>:</p>
    <p class="dropspot"><img alt="LMB Icon" class="icon" src="../assets/Images/Icons/Icon_LMB.png" /></p>
    <p class="dropspot">Usamos os eventos <strong>globais </strong>do mouse porque eles detectam um clique em qualquer lugar no <span class="notranslate">room</span>, enquanto os eventos regulares do mouse só detectarão um clique se o mouse realmente clicar dentro da <a class="glossterm" data-glossterm="caixa de delimitação" href="#">caixa de delimitação da</a> instância. Neste caso, queremos adicionar estas ações ou códigos:</p>
    <p class="dropspot"><img alt="Adding The Mouse Left Button Down Event" class="center" src="../assets/Images/QS_Guide/QS_Add_GlobalLMBDownEvent.png" /></p>
    <p class="code">move_towards_point(mouse_x, mouse_y, 2);</p>
    <p class="dropspot">Aqui estamos dizendo à instância para avançar em direção a uma posição na tela, neste caso a posição &quot;<span class="inline">mouse_x</span>&quot; e &quot;<span class="inline">mouse_y</span>&quot; (&quot;<span class="inline">mouse_x</span>&quot; e &quot;<span class="inline">mouse_y</span>&quot; são<span class="glossextra">variáveis</span> <strong>embutidas </strong> que sempre seguram a posição atual do cursor do mouse). O <span class="notranslate">GML</span> Visual faz isso definindo os &quot;<span class="inline">direction</span>&quot; e &quot; <span class="inline">speed</span>&quot;. <a href="../GameMaker_Language/GML_Reference/Asset_Management/Instances/Instance_Variables/Instance_Variables.htm"><strong>Variáveis de instância</strong></a>enquanto o <span class="notranslate">GML</span> o faz utilizando a função <a href="../GameMaker_Language/GML_Reference/Movement_And_Collisions/Movement/move_towards_point.htm"><span class="inline">move_towards_point()</span></a> (isto também define as variáveis <span class="inline">speed </span>e <span class="inline">direction </span>, apenas em uma função única e fácil de usar).</p>
    <p class="dropspot">Coloque uma instância deste <span class="notranslate">object</span> em um <span class="notranslate">room</span> e depois pressione o botão Play <img>, depois clique <img> ao redor do <span class="notranslate">room</span> para fazer com que a instância se mova em direção ao mouse:</p>
    <p class="dropspot"><img>Ótimo! A instância do <span class="notranslate">object</span> agora se move para onde você clicou, e se você segurar o botão, a instância continuará apenas seguindo o cursor do mouse. No entanto, há um problema... Depois que você clicar uma vez e soltar, a instância continuará se movendo e eventualmente deixará o <span class="notranslate">room</span>! Há várias maneiras de corrigir isso, e qual você escolherá dependerá do que você quer fazer, mas a solução mais fácil por enquanto é simplesmente adicionar um evento <strong>Global Mouse Button Released</strong>, então adicione isso agora ao <span class="notranslate">object</span> e dê a ele este código:</p>
    <p class="dropspot"><img alt="GML VisualTo Move Instance Towards Mouse" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_1_1.png" /></p>
    <p class="code">speed = 0;</p>
    <p class="dropspot">Com isso, a instância só seguirá o cursor do mouse enquanto o botão do mouse estiver pressionado, e quando você soltar o botão, ele parará de se mover. Pressione Play <img> e teste-o agora.</p>
    <p class="dropspot">Antes de deixarmos este exemplo, há uma última questão que precisamos resolver... Se você clicar e <em>segurar </em>o botão do mouse, mas não mover o cursor, então a instância se moverá em direção ao cursor e então &quot;vibrará&quot; em torno dele. Isto porque a instância está se movendo mais rápido do que 1 pixel de cada vez e por isso &quot;exagera&quot; a posição e depois tenta se mover para trás, e depois &quot;exagera&quot; novamente, etc... (faça a velocidade de movimento 5 ou algo parecido para ver o problema se não for imediatamente óbvio).</p>
    <p class="dropspot"><img>Para resolver isto, precisamos adicionar um <strong>Evento de Etapa</strong> ao <span class="notranslate">object</span> com este código:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">var _dist = point_distance(x, y, mouse_x, mouse_y);<br />
      <br />
      if (_dist &lt;= speed)<br />
      {<br />
          speed = 0;<br />
      }
    </p>
    <p class="dropspot">Aqui apenas verificamos a distância da instância até a posição do mouse, e se for igual ou menor que a velocidade atual, ajustamos a velocidade para 0. Isto faz com que a instância pare quando está perto o suficiente da posição do mouse, e não ficamos com aquele desagradável problema de &quot;vibração&quot;.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down1" href="#">Movimento de 4 e 8 vias com o Teclado</a></p>
  <div class="droptext" data-targetname="drop_down1">
    <p class="dropspot"><a href="What_Is_Programming_.htm">Logo no início deste guia</a>, mostramos a seguinte ação e código para mover uma instância para a direita por dois pixels a cada passo do jogo:</p>
    <p class="dropspot"><img alt="LMB Icon" class="icon" src="../assets/Images/Icons/Icon_LMB.png" /></p>
    <p class="code">x = x + 2;</p>
    <p class="dropspot">Este tipo de movimento é chamado movimento <strong>posicional </strong>, pois estamos essencialmente pegando a instância e colocando-a novamente em uma nova posição toda vez que o código é executado. O que vamos fazer neste exemplo é mostrar como usar este tipo de movimento para mover uma instância em 4 direções: para cima, para baixo, para a esquerda e para a direita.</p>
    <p class="dropspot">Para começar, abra um <span class="notranslate">object</span> e atribua-lhe um <span class="notranslate">sprite</span>. Agora, poderíamos adicionar vários <strong>Eventos de Teclado</strong> neste ponto, e em cada um deles ter a instância movendo-se na direção desejada, no entanto, queremos apenas que o jogador seja capaz de mover-se em uma direção de cada vez e fazer isso apenas com os eventos do teclado é um pouco mais complicado do que fazê-lo usando código. Em vez disso, vamos usar o <strong>Step Event</strong> - que você deve adicionar agora ao <span class="notranslate">object</span> - com as seguintes ações ou código para usar as Setas de Seleção para mover:</p>
    <p class="dropspot"><img alt="Animation Of Instance Moving Towards Mouse" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_1_1.gif" /></p>
    <p class="code">if keyboard_check(vk_left)<br />
      {<br />
          x = x - 2;<br />
      }<br />
      else if (keyboard_check(vk_right))<br />
      {<br />
          x = x + 2;<br />
      }<br />
      else if (keyboard_check(vk_up))<br />
      {<br />
          y = y - 2;<br />
      }<br />
      else if (keyboard_check(vk_down))<br />
      {<br />
          y = y + 2;<br />
      }</p>
    <p class="dropspot">Estamos usando uma estrutura &quot; <span class="inline">if... else if... else if...</span>&quot; para garantir que a instância se mova apenas em uma direção de cada vez, e assim a instância só deve ser capaz de mover-se para cima, para baixo, para a esquerda ou para a direita, mas não em diagonal. Coloque uma instância do <span class="notranslate">object</span> em um <span class="notranslate">room</span> e pressione o botão <strong>Play </strong> <img> para testá-la agora! Se tudo tiver corrido corretamente, você deve ter algo assim:</p>
    <p class="dropspot"><img alt="GML VisualTo Set The Instance Speed" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_1_2.png" /></p>
    <p class="dropspot">Podemos modificar este código para converter o movimento de 4 vias em 8 vias facilmente também... basta remover os comandos &quot; <span class="inline">else</span>&quot; dos blocos de código para que tudo se pareça com isto:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">if keyboard_check(vk_left)<br />
      {<br />
          x = x - 2;<br />
      }<br />
      if (keyboard_check(vk_right))<br />
      {<br />
          x = x + 2;<br />
      }<br />
      if (keyboard_check(vk_up))<br />
      {<br />
          y = y - 2;<br />
      }<br />
      if (keyboard_check(vk_down))<br />
      {<br />
          y = y + 2;<br />
      }</p>
    <p class="dropspot">Agora, quando você apertar o botão <strong>Play </strong> <img>, ele se parecerá com algo parecido com isto:</p>
    <p class="dropspot"><img alt="Animation Showing Instance Vibrating" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_1_2.gif" /></p>
    <p class="dropspot">Uma última coisa que vale a pena notar para os usuários que codificam com <span class="notranslate">GML</span>... Ao utilizar o <span class="notranslate">GML</span> Visual você pode selecionar a tecla do teclado que deseja utilizar a partir de uma lista suspensa, mas com <span class="notranslate">GML</span> não é tão simples assim. Há uma série de <a href="../GameMaker_Language/GML_Reference/Game_Input/Keyboard_Input/Keyboard_Input.htm">constantes de teclado</a> que você pode usar - como as constantes de teclas de seta mostradas no código acima - mas <em>não </em>há constantes para as teclas alfanuméricas. Estas são tratadas de forma ligeiramente diferente, e exigem que você use a função <a href="../GameMaker_Language/GML_Reference/Strings/ord.htm"><span class="inline">ord()</span></a>. O código abaixo mostra como isto funcionaria usando WASD em vez das setas do teclado:</p>
    <p class="code">if keyboard_check(ord(&quot;A&quot;))<br />
      {<br />
          x = x - 2;<br />
      }<br />
      if (keyboard_check(ord(&quot;D&quot;)))<br />
      {<br />
          x = x + 2;<br />
      }<br />
      if (keyboard_check(ord(&quot;W&quot;)))<br />
      {<br />
          y = y - 2;<br />
      }<br />
      if (keyboard_check(ord(&quot;S&quot;)))<br />
      {<br />
          y = y + 2;<br />
      }</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down2" href="#">Movimento Gamepad</a></p>
  <div class="droptext" data-targetname="drop_down2">
    <p class="dropspot">Nós cobrimos o movimento do mouse e do teclado, o que significa que é hora de cobrir o movimento do <strong>gamepad </strong>. Agora, não vamos cobrir o d-pad, pois isso realmente funciona exatamente como usar o teclado (basta mudar as funções do teclado no exemplo acima para <a href="../GameMaker_Language/GML_Reference/Game_Input/GamePad_Input/gamepad_button_check.htm"><span class="inline">gamepad_button_check()</span></a> ou <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Gamepad/If_Gamepad_Button_Down.htm">Se Gamepad botão Down</a>), então neste exemplo veremos o uso do bastão analógico para movimento.</p>
    <p class="dropspot">Para começar, precisamos detectar o gamepad que está sendo usado. Os gamepads recebem um valor de ID de 0 a 11, então usaremos um &quot; <span class="inline">for</span>&quot; <span class="notranslate">loop</span> para detectar a ID de qualquer gamepad conectado e armazenar este valor de ID em uma variável para uso futuro. Uma vez que queremos apenas setecionar o primeiro gamepad conectado e não todos, usaremos o comando &quot; <span class="inline">break</span>&quot; após detectarmos um gamepad para que ele &quot;quebre&quot; o <span class="notranslate">loop</span> (por exemplo, se o primeiro gamepad conectado for ID 4, então o <span class="notranslate">loop</span> só rodará 5 vezes, verificando os valores de ID 0 - 4 e depois quebrando o <span class="notranslate">loop</span> quando o gamepad for encontrado). Então, faça (ou abra) um <span class="notranslate">object</span>, atribua-lhe um <span class="notranslate">sprite</span>, e então adicione um <strong>Create Event</strong> com o seguinte:</p>
    <p class="dropspot"><img alt="GML VisualActions For The Step Event" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_1_3.png" /></p>
    <p class="code">gamepad_id = -1;<br />
      <br />
      for (var i = 0; i &lt; 12; i += 1;)<br />
      {<br />
          if (gamepad_is_connected(i)) <br />
          {<br />
              gamepad_id = i;<br />
              gamepad_set_axis_deadzone(gamepad_id, 0.2);<br />
      <br />
              break;<br />
          }<br />
      }
    </p>
    <p class="dropspot">Observe que no código acima estabelecemos o <strong> <a class="glossterm" data-glossterm="deadzone" href="#">deadzone</a> </strong>para o gamepad. Isto porque os bastões analógicos em diferentes marcas de gamepads terão sensibilidade diferente, e às vezes eles podem ser tão sensíveis que, se você não definir uma zona morta, eles podem causar movimentos indesejados em seus jogos. Portanto, definimos a zona morta com um valor como 0,2 para dizer ao <span data-keyref="GameMaker Name">GameMaker</span> para ignorar qualquer valor de varas de controle de jogo abaixo desse valor <a class="glossterm" data-glossterm="absoluto" href="#">absoluto</a>.</p>
    <p class="dropspot">Para adicionar o movimento real, precisaremos de um <strong>Evento Passo</strong>, então adicione isso agora e dê o seguinte <span class="notranslate">GML</span> Visual ou GML:</p>
    <p class="dropspot"><img alt="GML VisualExample" class="center" src="../assets/Images/QS_Guide/QS_DnD_Example.png" /></p>
    <p class="code">if gamepad_id &gt; -1<br />
      {<br />
          var _h = gamepad_axis_value(gamepads[0], gp_axislh);<br />
          var _v = gamepad_axis_value(gamepads[0], gp_axislv);<br />
          x += _h * 4;<br />
          y += _v * 4;<br />
      }</p>
    <p class="dropspot">Aqui estamos verificando o bastão <em>esquerdo </em>para movimento horizontal ou vertical. As funções do eixo retornam um valor entre -1 e 1, assim para o eixo horizontal -1 é esquerda, 0 não se move e 1 é direita, e para o eixo vertical é -1 para cima, 0 para não se move e 1 para baixo. Observe também que os valores estão <em>entre </em>-1 e 1, portanto - por exemplo - o eixo horizontal poderia retornar um valor de 0,5, significando que o bastão está na metade do caminho entre a posição &quot;repouso&quot; e totalmente empurrado para a direita. Por esta razão, multiplicamos então o valor por 4 (você pode multiplicar por qualquer valor realmente, dependendo da velocidade que você quer que a instância se mova) - isto significa que a velocidade da instância variará dependendo de quanto de um movimento foi feito no eixo da vara.</p>
    <p class="dropspot">Coloque um exemplo disto <span class="notranslate">object</span> em um <span class="notranslate">room</span> e pressione o botão <strong>Play </strong><strong> <img></strong>e, em seguida, movimente-se usando o bastão esquerdo de seu GamePad conectado. Você deveria ver algo como isto:</p>
    <p class="dropspot"><img alt="GML VisualStep Event Movement Actions" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_2_1.png" /></p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down3" href="#">Movimento Avançado de 8 Vias</a></p>
  <div class="droptext" data-targetname="drop_down3">
    <p class="dropspot">Neste último exemplo, vamos revisitar nosso código de movimento de 8 vias e abordar um problema que ele tem, que é que o movimento diagonal é na verdade mais rápido que o movimento para cima/baixo/esquerda/direita. Isto é simplesmente porque ao mover-se em diagonal, você está se movendo ao longo da hipotenusa de um triângulo em ângulo reto criado pelos valores do movimento x/y:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="dropspot">Para tornar mais claro o que está acontecendo, vamos remover todo o texto e <span class="notranslate">sprites</span> e simplesmente mostrar a mesma linha de movimento rodada 45° para que seja horizontal:</p>
    <p class="dropspot"><img alt="Animation Showing 4-Way Keyboard Movement" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_2_1.gif" /></p>
    <p class="dropspot">Como você pode ver, a diferença é bastante óbvia, e se a instância se move mais de 1 ou 2 pixels por degrau, então se torna muito perceptível que o movimento diagonal é <em>muito </em>mais rápido! Então, como limitar isso? Há várias maneiras de fazer isso, mas vamos nos concentrar em apenas uma delas, porque ela introduz algumas funções e conceitos que serão úteis para você mais tarde em seus jogos.</p>
    <p class="dropspot">Para lidar com isso, teremos que armazenar os valores de entrada das teclas pressionadas independentemente em<span class="glossextra">variáveis</span>, e então verificá-las e movê-las de acordo com a combinação de teclas que foram pressionadas. Portanto, para isto você precisará de um <span class="notranslate">object</span> com um <span class="notranslate">sprite</span> atribuído, e você precisará dar-lhe um <strong>Evento de Passo</strong> com as seguintes ações ou código:</p>
    <p class="dropspot"><img alt="GML VisualStep Event Movement Actions" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_2_2.png" /></p>
    <p class="note"><span class="note">OBSERVAÇÃO</span> Dividimos as ações visuais acima em duas colunas para facilitar a visualização, mas no editor Visual, ele será colocado consecutivamente.</p>
    <p class="code">var _left = keyboard_check(vk_left);<br />
      var _right = keyboard_check(vk_right);<br />
      var _up = keyboard_check(vk_up);<br />
      var _down = keyboard_check(vk_down);<br />
      var _hspd = _right - _left;<br />
      var _vspd = _down - _up;</p>
    <p class="dropspot">Precisaremos acrescentar mais algum código para realmente nos movermos, mas antes disso, vamos apenas explicar um pouco. Queremos converter esquerda/direita/cima/baixo em valores de velocidade horizontais e verticais equivalentes, de modo que estamos obtendo o valor de cada chave e depois fazendo algumas contas básicas para obter os valores de velocidade. Isto funciona porque se uma tecla estiver sendo pressionada, então a ação ou função de verificação retornará &quot;1&quot;, e se <em>não </em>estiver sendo pressionada, então a função retornará 0. Então, se - por exemplo - a direita está sendo pressionada, você tem &quot;1 - 0 = 1&quot; para o &quot; <span class="inline">_hspd</span>&quot;, e se a esquerda está sendo pressionada, você tem &quot;0 - 1 = -1&quot; para o &quot; <span class="inline">_hspd</span>&quot; (e se ambos são pressionados, então é &quot;1 - 1 = 0&quot;, então a instância não se moverá). Lembre-se, em um <span data-keyref="GameMaker Name">GameMaker</span> <span class="notranslate">room</span>, para mover à direita adicionamos à posição <span class="inline">x </span>e para mover à esquerda subtraímos, então este código nos dará um valor positivo ou negativo que podemos adicionar ou subtrair para mover horizontal ou verticalmente, dependendo da entrada do teclado.</p>
    <p class="dropspot">Agora podemos adicionar o código que realmente move a instância, então - ainda no <strong>Step Event</strong>, e após o código acima - adicione isto:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">if (_hspd != 0 || _vspd != 0)<br />
      {<br />
          var _spd = 4;<br />
          var _dir = point_direction(0, 0, _hspd, _vspd);<br />
          var _xadd = lengthdir_x(_spd, _dir);<br />
          var _yadd = lengthdir_y(_spd, _dir);<br />
          x = x + _xadd;<br />
          y = y + _yadd;<br />
      }</p>
    <p class="dropspot">O código acima verifica primeiro se uma de duas<span class="glossextra">expressões</span> é verdadeira, ou seja: se as variáveis de velocidade horizontal ou vertical não são 0. Observe como a verificação &quot; <span class="inline">if</span>&quot; <span class="notranslate">GML</span> usa o símbolo &quot; <span class="inline">||</span>&quot;. Isto significa &quot; <span class="inline">or</span>&quot; ao programar, portanto - em linguagem simples - você está verificando</p>
    <p class="code">if the variable _hspd does not equal zero<br />
      <strong>or</strong><br />
      if the variable _vspd does not equal zero
    </p>
    <p class="dropspot">Você pode <span class="notranslate">string</span> várias expressões juntas em &quot; <span class="inline">if</span>&quot; verifica desta forma, e há várias maneiras diferentes de avaliar estas expressões (para mais informações, consulte a seção sobre <strong>Expressões</strong> <a href="../GameMaker_Language/GML_Overview/Expressions_And_Operators.htm">aqui</a>).</p>
    <p class="dropspot">A seção seguinte do código armazena um valor para a velocidade real do movimento em uma variável e depois recebe uma direção usando os valores <span class="inline">_hspd </span>e <span class="inline">_vspd </span>, que podem ser -1, 0, ou 1. A função de direção verifica a partir de (0, 0) como não estamos usando as coordenadas <span class="notranslate">room</span>, e em vez disso queremos que ela seja avaliada como uma direção de 0° a 360° com base nos valores das variáveis. O diagrama a seguir ilustra melhor o que está acontecendo do que tentar explicá-lo por palavras:</p>
    <p class="dropspot"><img alt="Animation Showing 8-Way Keyboard Movement" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_2_2.gif" /></p>
    <p class="note"><span class="note">NOTA</span> A direção no <span data-keyref="GameMaker Name">GameMaker</span> é calculada no <strong>sentido anti-horário</strong>, portanto 0° e 360° são para a direita, 90° é para cima, 180° é para a direita e 270° é para baixo.</p>
    <p class="dropspot">Finalmente, usamos o <a href="../GameMaker_Language/GML_Reference/Maths_And_Numbers/Angles_And_Distance/lengthdir_x.htm"><span class="inline">lengthdir_x()</span></a> e <a href="../GameMaker_Language/GML_Reference/Maths_And_Numbers/Angles_And_Distance/lengthdir_y.htm"><span class="inline">lengthdir_y()</span></a> para realmente mover a variável. Estas são <strong> <a class="glossterm" data-glossterm="vetor" href="#">vetor</a>  </strong>funções que tomam um comprimento (distância) e uma direção e depois calcular a nova posição no eixo dado com base nestes valores (veja as descrições das funções para uma explicação mais aprofundada).</p>
    <p class="dropspot">Isso é muito para absorver de uma só vez, e não se preocupe se você não entender tudo isso! Com o tempo, você entenderá! Tudo o que falta fazer agora é adicionar uma instância deste <span class="notranslate">object</span> a um <span class="notranslate">room</span>, e depois pressionar o botão <strong>Play </strong><strong> <img></strong>e você deve ter um movimento suave como seda de 8 vias sem nenhuma das questões relacionadas à movimentação em diagonal:</p>
    <p class="dropspot"><img alt="Getting Gamepad ID Using DnD" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_3_1.png" /></p>
  </div>
  <p> </p>
  <p>Com estes exemplos - e os anteriores para o desenho - esperamos que você tenha um entendimento suficiente para começar a fazer seus próprios projetos! A última página deste Guia Rápido contém um resumo de algumas das coisas que você aprendeu, assim como links para materiais de aprendizagem adicionais.</p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Voltar: <a href="../Content.htm">Índice</a></div>
        <div style="float:right">A seguir: <a href="Summary.htm">Sumário</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Todos os direitos reservados</span></h5>
  </div>
  <!-- KEYWORDS
Movement
Controls
Movement and Controls
Movement Examples
Controls Examples
-->
  <!-- TAGS
qs_movement_controls
-->
</body>
</html>